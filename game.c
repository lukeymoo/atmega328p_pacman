#include "game.h"

const uint8_t SUCCESS_SCREEN [] PROGMEM = {
	// 'success', 128x64px
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xfc, 0xfc, 0xf0,
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xfe, 0xfc, 0xf0, 0x00, 0x00, 0x00,
	0x00, 0x08, 0x1c, 0x1c, 0x9c, 0xdc, 0xdc, 0xfc, 0xfc, 0x38, 0x70, 0xf0, 0xe0, 0xc0, 0x80, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x3f, 0xfe, 0xf8, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x38, 0xfc, 0xf8, 0xe0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x18, 0x3c, 0xf8, 0xf0, 0xe0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x07,
	0x0f, 0x1e, 0x1c, 0x1c, 0x1c, 0x3c, 0x7c, 0xfc, 0xfe, 0x8f, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xf0, 0xfe, 0xff, 0xff, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x07, 0x0f, 0x1c, 0x38, 0x70, 0xf0,
	0xe0, 0xe0, 0xc0, 0xc0, 0x80, 0x81, 0xff, 0xff, 0xff, 0x4f, 0x3c, 0x38, 0xf0, 0xe0, 0xc0, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0f, 0x7f, 0xfe, 0xf8, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x3f, 0xff, 0xff, 0xf0, 0xc0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x03, 0x07, 0x07, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x07, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x01, 0x01, 0x03, 0x07, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03,
	0x07, 0x0f, 0x07, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x1f, 0x7f, 0xfc, 0xf0, 0xc0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x1f, 0x3f, 0xff, 0xfc, 0xf0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xf8, 0xf8, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38,
	0xfe, 0xff, 0xff, 0xfe, 0xf8, 0xe0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
	0x1f, 0xff, 0xfe, 0xf0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x0f, 0x1f,
	0x3e, 0x78, 0xf0, 0xe0, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x0f, 0x3f, 0xfc, 0xf8, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xc0, 0xfc, 0xfe, 0xfe, 0xfc, 0xc0, 0x80, 0x80, 0x00, 0x00, 0x00, 0xa1, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xff, 0xff, 0xff, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x0f, 0x7f, 0xff, 0xff, 0xff, 0xc7, 0x0f, 0x1e, 0x3c, 0x78, 0xf0, 0xe0, 0x80, 0x80, 0x00,
	0x00, 0x00, 0x0f, 0xff, 0xff, 0xfc, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x03, 0x07, 0x1f, 0x3e, 0x78, 0x70, 0xf0, 0xf0, 0xe0, 0xe0, 0xe0, 0xf8,
	0x7e, 0x3f, 0x0f, 0x03, 0x00, 0x01, 0x03, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x03, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x1f, 0x3f, 0x7f, 0x3f, 0x03, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x07, 0x0f, 0x1f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x07, 0x0f,
	0x0e, 0x1c, 0x38, 0x78, 0xff, 0x7f, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const uint8_t FAIL_SCREEN [] PROGMEM = {
	// 'fail', 128x64px
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xf8,
	0xf8, 0xf0, 0xe0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
	0xf0, 0xf0, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x80, 0xc0, 0xe0, 0xfc, 0xfe, 0xff, 0xef, 0x0f, 0x0f, 0x0f, 0x0f, 0x1e, 0x1e, 0x1e, 0x3c,
	0x7c, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x1c, 0x7c, 0xfc, 0xf8, 0xe0, 0xc0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x7f, 0xff, 0xff, 0xf8, 0xe0, 0xc0, 0x80, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x03, 0x07, 0x1f, 0x1f, 0x3e, 0x7e, 0x78, 0x78, 0x70, 0xf0, 0xf0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff,
	0xbf, 0x0f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc,
	0xff, 0xff, 0xff, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x01, 0x03, 0x07, 0x1f, 0x3f, 0x3e, 0x7c, 0xf8,
	0xf0, 0xe0, 0xc0, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0x6f, 0x1f, 0x3f, 0x3e,
	0x3c, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7e, 0xfe, 0xfe, 0xf8, 0xe0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x3f, 0xff,
	0xff, 0xfe, 0xe0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
	0x0f, 0x1f, 0x7f, 0x7c, 0xf8, 0xf0, 0xf0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xf0, 0xf0,
	0xf8, 0x78, 0x7e, 0x3f, 0x1f, 0x0f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x03, 0x03, 0x07, 0x07, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x07, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x0f, 0x3f, 0xff, 0xff, 0xfc, 0xf0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x03, 0x0f, 0x1f, 0x1f, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0xc0, 0xc0, 0xc0, 0xc0, 0xe0,
	0xe0, 0xe0, 0xc0, 0xc0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xfc, 0xfc, 0xfc, 0xfc, 0xdc, 0x9c, 0x9c, 0x9c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x9c, 0x9c, 0xbc,
	0xbc, 0x3c, 0x3c, 0x00, 0x00, 0x00, 0x01, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xf8,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xe0, 0xf8, 0xfc,
	0x7c, 0x3c, 0x1e, 0x1e, 0x1f, 0x0f, 0x0f, 0x0e, 0x0e, 0x1e, 0x3e, 0x3c, 0xfc, 0xf8, 0xf0, 0xe0,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x1f, 0x1f, 0x3f, 0x3f, 0x3f, 0x3d, 0x79,
	0x79, 0x79, 0xf1, 0xf1, 0xf0, 0xe0, 0xe0, 0xe0, 0xc0, 0xc0, 0xc0, 0x80, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x03, 0x0f, 0x1f, 0x3f, 0x7f, 0xff, 0xff, 0xef, 0xcf, 0x8f, 0x0f, 0x0f, 0x0f, 0x07, 0x07,
	0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x7f, 0x7f,
	0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
	0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0x70, 0x00, 0x00, 0x3e, 0x3f, 0xff, 0xff, 0xf0,
	0xe0, 0xe0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe0, 0xe0, 0xe0, 0xf0, 0xf0, 0xff, 0x7f, 0x3f,
	0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x1e, 0x1e, 0x3f, 0x3f,
	0x3f, 0x3e, 0x78, 0x78, 0x79, 0x71, 0xf1, 0xf3, 0x73, 0x73, 0x77, 0x77, 0x7f, 0x7f, 0x7f, 0x7f,
	0x3e, 0x3e, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x07, 0x0f, 0x0f, 0x1f, 0x3e, 0x3e, 0x3c,
	0x7c, 0x78, 0x78, 0x78, 0x7e, 0x7e, 0x7e, 0x00, 0x00, 0x00, 0x30, 0x78, 0x78, 0x78, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

void show_sucess()
{
	for(int i = 0; i < 1024; i++) {
		lcd_data(pgm_read_byte(&SUCCESS_SCREEN[i]));
	}
	_delay_ms(3000);
	reset();
	return;
}

void show_fail()
{
	for(int i = 0; i < 1024; i++) {
		lcd_data(pgm_read_byte(&FAIL_SCREEN[i]));
	}
	_delay_ms(3000);
	reset();
	return;
}

void reset()
{
	init_input();
	init_game();
	init_map();
	return;
}

// Initialize special values & pointers
void init_game()
{
	player.x = 0;
	player.y = 24;
	player.animation = 0;
	player.direction = RIGHT;
	player.lives = retainer;
	player.score = 0;
	player.loaded_open = PACMAN_OPEN_RIGHT;
	player.loaded_closed = PACMAN_CLOSED_RIGHT;
	player.dead = 0;
	
	// Initialize enemies
	ghost.x = 56;
	ghost.y = 16;
	ghost.direction = LEFT;
	ghost.last_direction = LEFT;
	ghost.pixels_moved = 0;
	ghost.blocked = 0;
	
	USER_INPUT = PINC; // default 0 -- we only use lower 4 bits 0x0f
	return;
}

// Initializes pins on port C for user input
void init_input(void)
{
	DDRC &= ~0x0f; // lower 4 pins for input
	PORTC |= 0x0f;
	USER_INPUT = PINC;
	return;
}

uint8_t is_wall(uint8_t x, uint8_t y)
{
	if( (pgm_read_byte(&COLLISION_MAP[y][x])) != WALL &&
		(pgm_read_byte(&COLLISION_MAP[y][x])) != WALL	) {
		return 0;
	}
	return 1;
}

/*
	Convert PIXEL COORD to BLOCK COORD to avoid memory access error in COLLISION_MAP
*/
GAME_OBJECT *is_object(PLAYER_STRUCT *player, uint8_t x, uint8_t y)
{
	uint8_t x_calc, y_calc;
	// Check collision map for object with various coordinates based on direction
	switch(player->direction) {
		case UP:
			// test player top
			x_calc = ((x+2)/8);
			y_calc = ((y+2)/8);
			if( pgm_read_byte(&COLLISION_MAP[y_calc][x_calc]) == POINT ||
				pgm_read_byte(&COLLISION_MAP[y_calc][x_calc]) == ABILITY ) {
					// object detected -- fetch from OBJECT_MAP
					for(uint8_t i = 0; i < 128; i++) {
						if(OBJECT_MAP[i].x == x_calc && OBJECT_MAP[i].y == y_calc) {
							// found object -- return pointer
							return &OBJECT_MAP[i];
						}
					}
			}
			break;
		case DOWN:
			x_calc = ((x+1)/8);
			y_calc = ((y+4)/8);
			// test player bottom
			if( pgm_read_byte(&COLLISION_MAP[y_calc][x_calc]) == POINT ||
				pgm_read_byte(&COLLISION_MAP[y_calc][x_calc]) == ABILITY ) {
					// object detected -- fetch from OBJECT_MAP
					for(uint8_t i = 0; i < 128; i++) {
						if(OBJECT_MAP[i].x == x_calc && OBJECT_MAP[i].y == y_calc) {
							// found object -- return pointer
							return &OBJECT_MAP[i];
						}
					}
			}
			break;
		case LEFT:
			x_calc = ((x+2)/8);
			y_calc = ((y+2)/8);
			// test player left
			if( pgm_read_byte(&COLLISION_MAP[y_calc][x_calc]) == POINT ||
				pgm_read_byte(&COLLISION_MAP[y_calc][x_calc]) == ABILITY ) {
					// object detected -- fetch from OBJECT_MAP
					for(uint8_t i = 0; i < 128; i++) {
						if(OBJECT_MAP[i].x == x_calc && OBJECT_MAP[i].y == y_calc) {
							// found object -- return pointer
							return &OBJECT_MAP[i];
						}
					}
			}
			break;
		case RIGHT:
			x_calc = ((x+4)/8);
			y_calc = ((y+2)/8);
			if( pgm_read_byte(&COLLISION_MAP[y_calc][x_calc]) == POINT ||
				pgm_read_byte(&COLLISION_MAP[y_calc][x_calc]) == ABILITY ) {
					// object detected -- fetch from OBJECT_MAP
					for(uint8_t i = 0; i < 128; i++) {
						if(OBJECT_MAP[i].x == x_calc && OBJECT_MAP[i].y == y_calc) {
							// found object -- return pointer
							return &OBJECT_MAP[i];
						}
					}
			}
			break;
	}
	return NULL;
}

uint8_t check_collision(PLAYER_STRUCT *player, uint8_t direction)
{
	switch(direction) {
		case LEFT:
		// check screen bounds
		if((player->x - 1) > 0) {
			// Player Top Left corner
			if(!is_wall( ((player->x - 1) / 8), (player->y / 8) )) {
				// Player bottom left corner
				if(!is_wall( ((player->x - 1) / 8), ((player->y + 7) / 8) )) {
					return 0;
				}
			}
		}
		break;
		case RIGHT:
		// check screen bounds
		if((player->x + 8) < 128) {
			// Player Top Right corner
			if(!is_wall( ((player->x+8)/8), (player->y/8) )) {
				// Player bottom right corner
				if(!is_wall( ((player->x+8)/8), ((player->y+7)/8) )) {
					return 0;
				}
			}
		}
		break;
		case UP:
		// check screen bounds
		if((player->y - 1) > 0) {
			// Player Top Left corner
			if(!is_wall( (player->x/8), ((player->y-1)/8) )) {
				// Player Top right corner
				if(!is_wall( ((player->x+7)/8), ((player->y-1)/8) )) {
					return 0;
				}
			}
		}
		break;
		case DOWN:
		// check screen bounds
		if((player->y + 8) < 64) {
			// Player Bottom Left corner
			if(!is_wall( (player->x/8), ((player->y+8)/8) )) {
				// Player Bottom right corner
				if(!is_wall( ((player->x+7)/8), ((player->y+8)/8) )) {
					return 0;
				}
			}
		}
		break;
	} // end switch
	return 1;
}

// Checks state of buttons & updates sprite pointers
void check_input(PLAYER_STRUCT *player)
{
	// Capture current key states
	USER_INPUT = PINC;
	
	// Check key up
	if(! ( USER_INPUT & (1 << KEY_UP) ) ) {
		// Ensure player can move up
		if(!check_collision(player, UP)) {
			player->loaded_open = PACMAN_OPEN_UP;
			player->loaded_closed = PACMAN_CLOSED_UP;
			player->direction = UP;
		}
	}
	// Check key down
	if(! ( USER_INPUT & (1 << KEY_DOWN) ) ) {
		if(!check_collision(player, DOWN)) {
			player->loaded_open = PACMAN_OPEN_DOWN;
			player->loaded_closed = PACMAN_CLOSED_DOWN;
			player->direction = DOWN;
		}
	}
	// check key right
	if(! ( USER_INPUT & (1 << KEY_RIGHT) ) ) {
		if(!check_collision(player, RIGHT)) {
			player->loaded_open = PACMAN_OPEN_RIGHT;
			player->loaded_closed = PACMAN_CLOSED_RIGHT;
			player->direction = RIGHT;
		}
	}
	// check key left
	if(! ( USER_INPUT & (1 << KEY_LEFT) ) ) {
		if(!check_collision(player, LEFT)) {
			player->loaded_open = PACMAN_OPEN_LEFT;
			player->loaded_closed = PACMAN_CLOSED_LEFT;
			player->direction = LEFT;
		}
	}
	return;
}

// Draws the tiles that shape map
void draw_map(const uint8_t *map, uint16_t size)
{
	for(uint8_t y = 0; y < LCD_HEIGHT/8; y++) {
		for(uint8_t x = 0; x < LCD_WIDTH; x++) {
			BUFFER[y][x] = pgm_read_byte(&map[x + y * LCD_WIDTH]);
		}
	}
	return;
}

// Draws the special abilities & regular points on map
//void draw_objects() {
	//int height = 8;
	//int width = 16;
	//for(uint8_t y = 0; y < height; y++) {
		//for(uint8_t x = 0; x < width; x++) {
			//// DRAW REGULAR POINTS
			//if(pgm_read_byte(&COLLISION_MAP[y][x]) == 0) {
				//BUFFER[y][x * 8] = 0x00;
				//BUFFER[y][x * 8 + 1] = 0x00;
				//BUFFER[y][x * 8 + 2] = 0x00;
				//BUFFER[y][x * 8 + 3] = 0x18;
				//BUFFER[y][x * 8 + 4] = 0x18;
				//BUFFER[y][x * 8 + 5] = 0x00;
				//BUFFER[y][x * 8 + 6] = 0x00;
				//BUFFER[y][x * 8 + 7] = 0x00;
			//}
			//// DRAW ABILITY POINTS
			//if(pgm_read_byte(&COLLISION_MAP[y][x]) == 2) {
				//BUFFER[y][x * 8] = 0x00;
				//BUFFER[y][x * 8 + 1] = 0x00;
				//BUFFER[y][x * 8 + 2] = 0x1c;
				//BUFFER[y][x * 8 + 3] = 0x1c;
				//BUFFER[y][x * 8 + 4] = 0x1c;
				//BUFFER[y][x * 8 + 5] = 0x1c;
				//BUFFER[y][x * 8 + 6] = 0x00;
				//BUFFER[y][x * 8 + 7] = 0x00;
			//}
		//}
	//}
//}

// Draws Objects using OBJECT_MAP
void draw_objects(void)
{
	for(uint8_t i = 0; i < 128; i++) {
		// DRAW SMALL POINTS
		if(OBJECT_MAP[i].active && OBJECT_MAP[i].type == POINT) {
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8] = 0x00;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 1] = 0x00;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 2] = 0x00;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 3] = 0x18;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 4] = 0x18;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 5] = 0x00;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 6] = 0x00;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 7] = 0x00;
		}
		// DRAW LARGE ABILITY POINTS
		if(OBJECT_MAP[i].active && OBJECT_MAP[i].type == ABILITY) {
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8] = 0x00;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 1] = 0x00;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 2] = 0x1c;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 3] = 0x1c;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 4] = 0x1c;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 5] = 0x1c;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 6] = 0x00;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 7] = 0x00;
		}
		// DRAW SPAWN GATE
		if(OBJECT_MAP[i].active && OBJECT_MAP[i].type == GATE) {
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8] = 0x08;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 1] = 0x08;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 2] = 0x08;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 3] = 0x08;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 4] = 0x08;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 5] = 0x08;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 6] = 0x08;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 7] = 0x08;
		}
		// DRAW WALLS
		if(OBJECT_MAP[i].active && OBJECT_MAP[i].type == WALL) {
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8] = 0xff;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 1] = 0xff;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 2] = 0xff;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 3] = 0xff;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 4] = 0xff;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 5] = 0xff;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 6] = 0xff;
			BUFFER[OBJECT_MAP[i].y][(OBJECT_MAP[i].x) * 8 + 7] = 0xff;
		}
	}
	return;
}

void debug_tile(PLAYER_STRUCT *player)
{
	uint8_t center_y = (player->y + 4) / 8;
	uint8_t center_x = ((player->x + 2) / 8) * 8; // truncate to tile
	
	BUFFER[center_y][center_x] |= 0xff;
	BUFFER[center_y][center_x + 1] |= 0x81;
	BUFFER[center_y][center_x + 2] |= 0x81;
	BUFFER[center_y][center_x + 3] |= 0x81;
	BUFFER[center_y][center_x + 4] |= 0x81;
	BUFFER[center_y][center_x + 5] |= 0x81;
	BUFFER[center_y][center_x + 6] |= 0x81;
	BUFFER[center_y][center_x + 7] |= 0xff;
	return;
}

/*
// Draws pacman, controls animation timing
void draw_pacman(void)
{
	uint8_t COL = 1;
	if(pacman_animation == 1) { // open mouth
		BUFFER[PLAYER_Y/8][PLAYER_X] = pgm_read_byte(&PACMAN_LOADED_OPEN[0]);
		BUFFER[PLAYER_Y/8][PLAYER_X + (COL++)] = pgm_read_byte(&PACMAN_LOADED_OPEN[1]);
		BUFFER[PLAYER_Y/8][PLAYER_X + (COL++)] = pgm_read_byte(&PACMAN_LOADED_OPEN[2]);
		BUFFER[PLAYER_Y/8][PLAYER_X + (COL++)] = pgm_read_byte(&PACMAN_LOADED_OPEN[3]);
		BUFFER[PLAYER_Y/8][PLAYER_X + (COL++)] = pgm_read_byte(&PACMAN_LOADED_OPEN[4]);
		BUFFER[PLAYER_Y/8][PLAYER_X + (COL++)] = pgm_read_byte(&PACMAN_LOADED_OPEN[5]);
		BUFFER[PLAYER_Y/8][PLAYER_X + (COL++)] = pgm_read_byte(&PACMAN_LOADED_OPEN[6]);
		BUFFER[PLAYER_Y/8][PLAYER_X + (COL++)] = pgm_read_byte(&PACMAN_LOADED_OPEN[7]);
		pacman_animation = 0;
	} else { // Closed mouth
		BUFFER[PLAYER_Y/8][PLAYER_X] = pgm_read_byte(&PACMAN_LOADED_CLOSED[0]);
		BUFFER[PLAYER_Y/8][PLAYER_X + (COL++)] = pgm_read_byte(&PACMAN_LOADED_CLOSED[1]);
		BUFFER[PLAYER_Y/8][PLAYER_X + (COL++)] = pgm_read_byte(&PACMAN_LOADED_CLOSED[2]);
		BUFFER[PLAYER_Y/8][PLAYER_X + (COL++)] = pgm_read_byte(&PACMAN_LOADED_CLOSED[3]);
		BUFFER[PLAYER_Y/8][PLAYER_X + (COL++)] = pgm_read_byte(&PACMAN_LOADED_CLOSED[4]);
		BUFFER[PLAYER_Y/8][PLAYER_X + (COL++)] = pgm_read_byte(&PACMAN_LOADED_CLOSED[5]);
		BUFFER[PLAYER_Y/8][PLAYER_X + (COL++)] = pgm_read_byte(&PACMAN_LOADED_CLOSED[6]);
		BUFFER[PLAYER_Y/8][PLAYER_X + (COL++)] = pgm_read_byte(&PACMAN_LOADED_CLOSED[7]);
		pacman_animation = 1;
	}
	return;
}
*/

void move(PLAYER_STRUCT *player) {
	switch(player->direction) {
		case LEFT:
			// check screen bounds
			if(!check_collision(player, LEFT)) {
				player->x --;
				// Check if player collided with object
				GAME_OBJECT *obj = is_object(player, player->x, player->y);
				// Delete object -- increment score
				if(obj != NULL) {
					if(obj->type == POINT && obj->active) {
						player->score ++;
					}
					if(obj->type == ABILITY && obj->active) {
						player->score += 2;
					}
					obj->active = 0;
				}
			}
			break;
		case RIGHT:
			// check screen bounds
			if(!check_collision(player, RIGHT)) {
				player->x ++;
				// Check if player collided with object
				GAME_OBJECT *obj = is_object(player, player->x, player->y);
				// remove object
				if(obj != NULL) {
					if(obj->type == POINT && obj->active) {
						player->score ++;
					}
					if(obj->type == ABILITY && obj->active) {
						player->score += 2;
					}
					obj->active = 0;
				}
			}
			break;
		case UP:
			// check screen bounds
			if(!check_collision(player, UP)) {
				player->y --;
				// Check if player collided with object
				GAME_OBJECT *obj = is_object(player, player->x, player->y);
				// remove object
				if(obj != NULL) {
					if(obj->type == POINT && obj->active) {
						player->score ++;
					}
					if(obj->type == ABILITY && obj->active) {
						player->score += 2;
					}
					obj->active = 0;
				}
			}
			break;
		case DOWN:
			// check screen bounds
			if(!check_collision(player, DOWN)) {
				player->y ++;
				// Check if player collided with object
				GAME_OBJECT *obj = is_object(player, player->x, player->y);
				// remove object
				if(obj != NULL) {
					if(obj->type == POINT && obj->active) {
						player->score ++;
					}
					if(obj->type == ABILITY && obj->active) {
						player->score += 2;
					}
					obj->active = 0;
				}
			}
			break;
	} // end switch
	return;	
}

void draw_sprite(PLAYER_STRUCT *player)
{
	if(player->animation == 1) { // BEGIN OPEN MOUTH
		for(int line = 0; line < 8; line++) {
			for(int column = 0; column < 8; column++) {
				if( pgm_read_byte(&player->loaded_open[line]) & (1 << column) ) {
					put_pixel(player->x + column, player->y+ line);
					} else {
					clear_pixel(player->x + column, player->y + line);
				}
			} // inner for
		} // outer 
		player->animation = 0;
	} /* END OPEN MOUTH */ else { // BEGIN CLOSED MOUTH
		for(int line = 0; line < 8; line++) {
			for(int column = 0; column < 8; column++) {
				if( pgm_read_byte(&player->loaded_closed[line]) & (1 << column) ) {
					put_pixel(player->x + column, player->y + line);
					} else {
					clear_pixel(player->x + column, player->y + line);
				}
			} // inner for
		} // outer for
		player->animation = 1;
	} // END CLOSED MOUTH
	return;
}

// Draw's score at bottom of screen
void draw_score(uint8_t score)
{
	char buf[10];
	sprintf(buf, "Score:%d", score);
	set_cursor(0, 7);
	overlay_print(buf);
	return;
}

// Draw life's bar
void draw_lives(uint8_t lives)
{
	char buf[10];
	sprintf(buf, "Lives:");
	for(uint8_t i = 0; i < lives; i++) {
		strcat(buf, "#");
	}
	set_cursor(LCD_WIDTH - (7 * 8), 7);
	overlay_print(buf);
	return;
}

// Draw enemy ghost
void draw_enemy(ENEMY_STRUCT *ghost)
{
	for(uint8_t line = 0; line < 8; line++) {
		for(uint8_t column = 0; column < 8; column++) {
			if( pgm_read_byte(&GHOST[line]) & (1 << column) ) {
				put_pixel(ghost->x + column, ghost->y+ line);
			} else {
				clear_pixel(ghost->x + column, ghost->y + line);
			}
		}
	}
	return;
}

// AI logic
// Iterate through neighboring blocks going 2 steps deep
// If path is not blocked, take the first step that lead there
void ai_logic(PLAYER_STRUCT *player, ENEMY_STRUCT *ghost)
{
	// check if enemy caught player
	if(((ghost->x + 2) / 8) == ((player->x + 2) / 8)) {
		if( ((ghost->y + 2) / 8) == ((player->y + 2) / 8) ) {
			player->dead = 1;
		}
	}
	
	if(ghost->blocked || (player->x == ghost->x && ghost->y != player->y)) {
		if(player->x < ghost->x) { // player left
			if(!check_collision((PLAYER_STRUCT *)ghost, LEFT)) {
				ghost->direction = LEFT;
			} else {
				if(player->y < ghost->y) { // go up
					ghost->direction = UP;
					if(check_collision((PLAYER_STRUCT *)ghost, UP)) {
						ghost->direction = DOWN;
					}
				} else { // go down
					ghost->direction = DOWN;
					if(check_collision((PLAYER_STRUCT *)ghost, DOWN)) {
						ghost->direction = UP;
					}
				}
			}
		} else if(player->x > ghost->x) { // player right
			if(!check_collision((PLAYER_STRUCT *)ghost, RIGHT)) {
				ghost->direction = RIGHT;
			} else {
				if(player->y < ghost->y) { // go up
					ghost->direction = UP;
					if(check_collision((PLAYER_STRUCT *)ghost, UP)) {
						ghost->direction = DOWN;
					}
				} else { // go down
					ghost->direction = DOWN;
					if(check_collision((PLAYER_STRUCT *)ghost, DOWN)) {
						ghost->direction = UP;
					}
				}
			}
		} else if(player->x == ghost->x) {
			if(player->y > ghost->y) { // go down
				ghost->direction = DOWN;
				if(check_collision((PLAYER_STRUCT *)ghost, DOWN)) {
					ghost->direction = LEFT;
				}
			} else { // go up
				ghost->direction = UP;
				if(check_collision((PLAYER_STRUCT *)ghost, UP)) {
					ghost->direction = RIGHT;
				}
			}
		}
		ghost->blocked = 0;
	}
	
	switch(ghost->direction) {
		case LEFT:
			if(!check_collision((PLAYER_STRUCT *)ghost, LEFT)) {
				if(ghost->pixels_moved <= 7) {
					ghost->x --;
					ghost->pixels_moved ++;	
				} else {
					ghost->pixels_moved = 0;
					ghost->last_direction = LEFT;
				}
			} else {
				ghost->blocked = 1;
			}
			break;
		case RIGHT:
			if(!check_collision((PLAYER_STRUCT *)ghost, RIGHT)) {
				if(ghost->pixels_moved <= 7) {
					ghost->x ++;
					ghost->pixels_moved ++;
				} else {
					ghost->pixels_moved = 0;
					ghost->last_direction = RIGHT;
				}
			} else {
				ghost->blocked = 1;
			}
			break;
		case UP:
			if(!check_collision((PLAYER_STRUCT *)ghost, UP)) {
				if(ghost->pixels_moved <= 7) {
					ghost->y --;
					ghost->pixels_moved ++;
				} else {
					ghost->pixels_moved = 0;
					ghost->last_direction = UP;
				}
			} else {
				ghost->blocked = 1;
			}
			break;
		case DOWN:
			if(!check_collision((PLAYER_STRUCT*)ghost, DOWN)) {
				if(ghost->pixels_moved <= 7) {
					ghost->y ++;
					ghost->pixels_moved ++;
				} else {
					ghost->pixels_moved = 0;
					ghost->last_direction = DOWN;
				}
			} else {
				ghost->blocked = 1;
			}
			break;
	}
	return;
}

// getter functions, make things neater for game logic
//int playerTopLeftX(PLAYER_STRUCT *player)
//{
	//return player->x;
//}
//
//int playerTopLeftY(PLAYER_STRUCT *player)
//{
	//return player->y;
//}
//
//int playerTopRightX(PLAYER_STRUCT *player)
//{
	//return player->x + 8;
//}
//
//int playerTopRightY(PLAYER_STRUCT *player)
//{
	//return player->y;
//}
//
//int playerBottomLeftX(PLAYER_STRUCT *player)
//{
	//return player->x;
//}
//
//int playerBottomLeftY(PLAYER_STRUCT *player)
//{
	//return player->y + 8;
//}
//
//int playerBottomRightX(PLAYER_STRUCT *player)
//{
	//return player->x + 8;
//}
//
//int playerBottomRightY(PLAYER_STRUCT *player)
//{
	//return player->y + 8;
//}
//
// For Collision map vertices
int cTopLeftX(PLAYER_STRUCT *player)
{
	return (player->x / 8);
}

int cTopLeftY(PLAYER_STRUCT *player)
{
	return (player->y / 8);
}
//
//int cTopRightX(PLAYER_STRUCT *player)
//{
	//return ((player->x + 8) / 8);
//}
//
//int cTopRightY(PLAYER_STRUCT *player)
//{
	//return (player->y / 8);
//}
//
//int cBottomLeftX(PLAYER_STRUCT *player)
//{
	//return (player->x / 8);
//}
//
//int cBottomLeftY(PLAYER_STRUCT *player)
//{
	//return ((player->y + 8) / 8);
//}
//
//int cBottomRightX(PLAYER_STRUCT *player)
//{
	//return ((player->x + 8) / 8);
//}
//
//int cBottomRightY(PLAYER_STRUCT *player)
//{
	//return ((player->y + 8) / 8);
//}

void display_debug(PLAYER_STRUCT *player) {
	set_cursor(0, 0);
	char buf[60];
	sprintf(buf, "Coords: (%d, %d)\r\ncBox: (%d, %d) -- %d\r\nColls: %d", player->x, player->y, cTopLeftX(player), cTopLeftY(player), pgm_read_byte(&COLLISION_MAP[(player->y/8)][(player->x/8)]), check_collision(player, player->direction));
	buf_print(buf);
}